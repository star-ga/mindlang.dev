<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="apple-touch-icon" href="/favicon.svg">
    <title>Fractal Voyager - MindLang GPU Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Inter', 'SF Pro Display', -apple-system, system-ui, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }

        .glass {
            background: linear-gradient(135deg, #1a1a24 0%, #12121a 100%);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        }

        #topBar {
            position: fixed; top: 12px; left: 12px; right: 12px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 16px; border-radius: 14px; color: #fff;
            z-index: 100;
        }
        #info {
            font-size: 14px; font-weight: 500; letter-spacing: 0.3px;
            line-height: 1.5; flex: 1;
        }
        #info .title { font-size: 16px; font-weight: 600; margin-bottom: 2px; }
        #info .api {
            display: inline-block; padding: 3px 8px; border-radius: 5px; font-size: 10px;
            font-weight: 600; letter-spacing: 0.5px; margin-left: 6px; vertical-align: middle;
        }
        #info .webgpu { background: linear-gradient(135deg, #00d4ff, #7b2ff7); }
        #info .webgl2 { background: linear-gradient(135deg, #ff6b35, #f7931e); }
        #info .stats { font-size: 11px; opacity: 0.9; font-family: 'SF Mono', 'Fira Code', monospace; }
        #info .highlight { color: #7af; }
        #info .perf { color: #5f5; }
        #info .dim { opacity: 0.6; }

        #controls {
            position: fixed; bottom: 20px; left: 20px; color: rgba(255,255,255,0.8);
            font-size: 13px; font-weight: 400; letter-spacing: 0.3px;
            padding: 12px 18px; border-radius: 12px;
            white-space: nowrap;
        }

        #gpuInfo {
            position: fixed; bottom: 20px; right: 20px; color: rgba(255,255,255,0.7);
            font-size: 11px; font-family: 'SF Mono', 'Fira Code', monospace;
            padding: 10px 16px; border-radius: 10px; text-align: right;
            max-width: 350px;
        }
        #gpuInfo .label { opacity: 0.5; }

        #githubLink {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            z-index: 100;
        }
        #githubLink.visible {
            opacity: 1;
            visibility: visible;
        }
        #githubLink svg {
            width: 48px;
            height: 48px;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.5));
            transition: transform 0.2s ease;
        }
        #githubLink:hover svg {
            transform: scale(1.1);
        }

        #topRight {
            display: flex; gap: 8px; align-items: center;
            flex-shrink: 0;
        }

        #resolution {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a24 100%);
            border: 1px solid rgba(255,255,255,0.12);
            color: #fff;
            padding: 10px 32px 10px 12px;
            font-size: 12px;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
            letter-spacing: 0.3px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 24px rgba(0,0,0,0.5);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='white' viewBox='0 0 16 16'%3E%3Cpath d='M4.5 5.5l3.5 4 3.5-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
        }
        #resolution:hover {
            background: linear-gradient(135deg, #3a3a4a 0%, #2a2a34 100%);
            border-color: rgba(255,255,255,0.25);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            transform: translateY(-1px);
        }
        #resolution:focus {
            outline: none;
            border-color: rgba(102,126,234,0.6);
            box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 0 3px rgba(102,126,234,0.2);
        }
        #resolution option {
            background: #1a1a24;
            color: #fff;
            padding: 12px 16px;
            font-weight: 400;
        }
        #resolution optgroup {
            background: #12121a;
            color: rgba(255,255,255,0.5);
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn {
            width: 36px; height: 36px; border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.15);
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a24 100%);
            color: #fff; font-size: 16px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease;
        }
        .btn:hover {
            background: linear-gradient(135deg, #3a3a4a 0%, #2a2a34 100%);
            border-color: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        .btn:active { transform: scale(0.95); }
        .btn.mobile-only { display: none; }
        .btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
            box-shadow: 0 4px 20px rgba(102,126,234,0.4);
        }

        /* API Switcher */
        .api-switcher {
            display: flex;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.15);
            background: linear-gradient(135deg, #1a1a24 0%, #12121a 100%);
        }
        .api-switcher button {
            padding: 6px 10px;
            border: none;
            background: transparent;
            color: rgba(255,255,255,0.5);
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        .api-switcher button:hover {
            color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.05);
        }
        .api-switcher button.active {
            color: #fff;
        }
        .api-switcher button.active.webgpu {
            background: linear-gradient(135deg, #00d4ff, #7b2ff7);
        }
        .api-switcher button.active.webgl2 {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
        }
        .api-switcher button.unavailable {
            opacity: 0.3;
            cursor: not-allowed;
            text-decoration: line-through;
        }
        .api-switcher button.unavailable:hover {
            background: transparent;
            color: rgba(255,255,255,0.3);
        }

        #startHint {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; align-items: center; justify-content: center;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.7) 100%);
            z-index: 9999;
        }
        .start-container {
            position: relative;
            display: flex; flex-direction: column;
            align-items: center; gap: 20px;
        }
        .start-glow {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; height: 150px;
            background: radial-gradient(ellipse, rgba(102,126,234,0.5) 0%, transparent 70%);
            filter: blur(40px);
            animation: glow-pulse 2s ease-in-out infinite;
        }
        @keyframes glow-pulse {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
        }
        .api-badge {
            font-size: 14px; font-weight: 600; letter-spacing: 1px;
            padding: 8px 20px; border-radius: 30px; color: #fff;
            text-transform: uppercase; z-index: 1;
        }
        .api-badge.webgpu { background: linear-gradient(135deg, #00d4ff, #7b2ff7); }
        .api-badge.webgl2 { background: linear-gradient(135deg, #ff6b35, #f7931e); }
        #startBtn {
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f64f59 100%);
            background-size: 200% 200%;
            animation: gradient-shift 4s ease infinite;
            border: none; color: #fff;
            padding: 26px 60px; border-radius: 70px;
            cursor: pointer;
            box-shadow:
                0 0 0 1px rgba(255,255,255,0.1) inset,
                0 20px 60px rgba(102,126,234,0.5),
                0 10px 30px rgba(0,0,0,0.4),
                0 0 100px rgba(118,75,162,0.3);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: inherit;
            display: flex; align-items: center; gap: 16px;
            overflow: hidden; z-index: 1;
        }
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #startBtn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s ease;
        }
        #startBtn:hover::before { left: 100%; }
        #startBtn .btn-text {
            font-size: 22px; font-weight: 600;
            letter-spacing: 0.8px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #startBtn .btn-icon {
            font-size: 18px;
            display: flex; align-items: center; justify-content: center;
            width: 36px; height: 36px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        #startBtn:hover {
            transform: translateY(-5px) scale(1.03);
            box-shadow:
                0 0 0 1px rgba(255,255,255,0.2) inset,
                0 30px 80px rgba(102,126,234,0.6),
                0 15px 40px rgba(0,0,0,0.5),
                0 0 150px rgba(118,75,162,0.4);
        }
        #startBtn:hover .btn-icon {
            background: rgba(255,255,255,0.35);
            transform: scale(1.1);
        }

        #error {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #3a1a1a 0%, #2a1212 100%);
            border: 1px solid rgba(255,100,100,0.3);
            padding: 30px 50px; border-radius: 20px; color: #fff;
            text-align: center; display: none;
        }
        #error h2 { margin-bottom: 15px; }
        #error a { color: #7af; }

        .start-instructions {
            z-index: 1;
            margin-bottom: 24px;
            text-align: center;
        }
        .instruction-text {
            color: rgba(255,255,255,0.9);
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 12px;
        }
        .instruction-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px 20px;
            justify-content: center;
            color: rgba(255,255,255,0.6);
            font-size: 13px;
        }
        kbd {
            display: inline-block;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 2px 8px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            color: #fff;
            margin-right: 4px;
        }

        .browser-help {
            max-width: 600px;
            margin-bottom: 30px;
            z-index: 1;
            text-align: center;
        }
        .browser-help-toggle {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.7);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.3px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .browser-help-toggle:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.4);
            color: #fff;
        }
        .browser-help-toggle .icon {
            transition: transform 0.3s ease;
        }
        .browser-help-toggle.expanded .icon {
            transform: rotate(180deg);
        }
        .browser-instructions {
            display: none;
            background: linear-gradient(135deg, #1a1a24 0%, #12121a 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 24px;
            margin-top: 16px;
            text-align: left;
            box-shadow: 0 8px 40px rgba(0,0,0,0.6);
            margin-left: auto;
            margin-right: auto;
        }
        .browser-instructions.visible {
            display: block;
            animation: slideDown 0.3s ease;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .browser-instructions h4 {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 16px 0;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .browser-list {
            display: grid;
            gap: 12px;
        }
        .browser-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 14px;
            background: rgba(255,255,255,0.03);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.05);
            transition: all 0.2s ease;
        }
        .browser-item:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.1);
        }
        .browser-icon {
            font-size: 20px;
            flex-shrink: 0;
            width: 28px;
            text-align: center;
        }
        .browser-info {
            flex: 1;
        }
        .browser-name {
            color: #fff;
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
        }
        .browser-name .check { color: #4f4; margin-left: 6px; }
        .browser-name .warning { color: #fa0; margin-left: 6px; font-size: 11px; }
        .browser-steps {
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            line-height: 1.5;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        .browser-steps code {
            background: rgba(102,126,234,0.2);
            color: #9af;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        /* Tablet styles */
        @media (max-width: 1024px) {
            #topBar { top: 10px; left: 10px; right: 10px; padding: 8px 14px; }
            #info { font-size: 13px; }
            #info .title { font-size: 15px; }
            #info .stats { font-size: 10px; }
            #controls { bottom: 10px; left: 10px; font-size: 11px; padding: 8px 12px; }
            #gpuInfo { display: none; }
            .btn { width: 34px; height: 34px; font-size: 15px; }
            #resolution { padding: 8px 36px 8px 12px; font-size: 12px; min-width: 130px; }
            .browser-instructions { padding: 16px; }
            .browser-item { padding: 10px 12px; }
        }

        /* Mobile/Tablet styles */
        @media (max-width: 768px) {
            #topBar {
                top: 8px; left: 8px; right: 8px;
                padding: 6px 10px;
                flex-wrap: nowrap; gap: 8px;
                border-radius: 10px;
                align-items: flex-start;
            }
            #info {
                flex: 1 1 auto;
                font-size: 11px;
                min-width: 0;
                text-align: left;
            }
            #info .title { font-size: 12px; margin-bottom: 2px; white-space: nowrap; }
            #info .api { padding: 2px 5px; font-size: 9px; margin-left: 3px; }
            #info .stats { font-size: 9px; white-space: normal; line-height: 1.4; }
            #topRight {
                flex: 0 0 auto;
                display: flex;
                align-items: center;
                gap: 4px;
            }
            #apiSwitcher { display: flex !important; }
            #resolution { display: none !important; }
            .btn { width: 28px; height: 28px; font-size: 12px; border-radius: 6px; }
            .btn.mobile-only { display: inline-flex; }
            #controls { display: none; }
            #startBtn { padding: 18px 36px; border-radius: 50px; }
            #startBtn .btn-text { font-size: 16px; }
            #startBtn .btn-icon { width: 28px; height: 28px; font-size: 14px; }
            .start-glow { width: 250px; height: 100px; }
            .api-badge { font-size: 11px; padding: 6px 14px; }
            .instruction-text { font-size: 13px; }
            .instruction-controls { display: none; }
            kbd { font-size: 10px; padding: 1px 5px; }
            .browser-help { max-width: 100%; padding: 0 16px; }
            .browser-help-toggle { font-size: 11px; padding: 8px 14px; }
            .browser-instructions { padding: 12px; border-radius: 12px; max-height: 50vh; overflow-y: auto; }
            .browser-instructions h4 { font-size: 12px; }
            .browser-item { padding: 8px 10px; gap: 8px; }
            .browser-icon { font-size: 16px; width: 22px; }
            .browser-name { font-size: 11px; }
            .browser-steps { font-size: 10px; }
            .browser-steps code { font-size: 9px; padding: 1px 4px; }
        }

        /* Very small screens */
        @media (max-width: 380px) {
            #topBar { padding: 6px 10px; gap: 6px; }
            #info .title { font-size: 11px; }
            #info .stats { font-size: 8px; }
            .btn { width: 28px; height: 28px; font-size: 12px; }
            #resolution { display: none; }
            #startBtn { padding: 14px 28px; }
            #startBtn .btn-text { font-size: 14px; }
            .instruction-controls { display: none; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="topBar" class="glass">
        <div id="info"></div>
        <div id="topRight">
            <button id="fractalBtn" class="btn mobile-only" title="Change Fractal">üåÄ</button>
            <button id="colorBtn" class="btn mobile-only" title="Change Color">üé®</button>
            <button id="muteBtn" class="btn active" title="Toggle Sound">üîä</button>
            <button id="autoBtn" class="btn" title="Toggle Auto-Zoom">‚ö°</button>
            <select id="resolution">
                <optgroup label="Auto">
                    <option value="auto" selected>DPI (Auto)</option>
                </optgroup>
                <optgroup label="16:9 Standard">
                    <option value="1280x720">720p HD</option>
                    <option value="1920x1080">1080p FHD</option>
                    <option value="2560x1440">1440p QHD</option>
                    <option value="3840x2160">4K UHD</option>
                    <option value="5120x2880">5K</option>
                    <option value="7680x4320">8K UHD</option>
                </optgroup>
                <optgroup label="Ultrawide">
                    <option value="3440x1440">UWQHD</option>
                    <option value="5120x2160">UW5K</option>
                </optgroup>
                <optgroup label="Apple">
                    <option value="3456x2234">MacBook Pro 16"</option>
                    <option value="6016x3384">Pro Display XDR</option>
                </optgroup>
            </select>
            <div class="api-switcher" id="apiSwitcher" title="Switch Rendering API">
                <button id="webgpuBtn">WebGPU</button>
                <button id="webgl2Btn">WebGL2</button>
            </div>
        </div>
    </div>
    <div id="controls" class="glass">
        1-4 Fractal ‚Ä¢ C Color ‚Ä¢ Z Auto ‚Ä¢ R Reset ‚Ä¢ Scroll Zoom ‚Ä¢ Drag Pan
    </div>
    <div id="gpuInfo" class="glass"></div>

    <a id="githubLink" href="https://github.com/cputer/fractal-voyager" target="_blank" title="View on GitHub">
        <svg viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/>
        </svg>
    </a>

    <input type="file" id="audioFile" accept="audio/*" style="display:none">

    <div id="startHint">
        <div class="start-container">
            <div class="start-glow"></div>
            <div id="apiBadge" class="api-badge">Detecting GPU...</div>
            <div class="start-api-selector" id="startApiSelector" style="z-index:1; margin-bottom: 20px;">
                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 8px; text-align: center;">Select Rendering API</div>
                <div class="api-switcher" style="transform: scale(1.3); transform-origin: center;">
                    <button id="startWebgpuBtn">WebGPU</button>
                    <button id="startWebgl2Btn">WebGL2</button>
                </div>
            </div>
            <button id="startBtn">
                <span class="btn-text">Click here to start</span>
                <span class="btn-icon">‚ñ∂</span>
            </button>
            <div class="start-instructions">
                <div class="instruction-text">Press <kbd>SPACE</kbd> or click the button to start</div>
                <div class="instruction-controls">
                    <span><kbd>1-4</kbd> Fractals</span>
                    <span><kbd>C</kbd> Colors</span>
                    <span><kbd>Z</kbd> Auto-zoom</span>
                    <span><kbd>R</kbd> Reset</span>
                    <span><kbd>Scroll</kbd> Zoom</span>
                    <span><kbd>Drag</kbd> Pan</span>
                </div>
            </div>
            <div class="browser-help">
                <button class="browser-help-toggle" id="browserHelpToggle">
                    <span>How to enable WebGPU</span>
                    <span class="icon">‚ñº</span>
                </button>
                <div class="browser-instructions" id="browserInstructions">
                    <h4>Enable WebGPU for Best Performance</h4>
                    <div class="browser-list">
                        <div class="browser-item">
                            <span class="browser-icon">üåê</span>
                            <div class="browser-info">
                                <div class="browser-name">Chrome 113+ (Windows/macOS) <span class="check">‚úì</span></div>
                                <div class="browser-steps">WebGPU enabled by default with native D3D12/Metal backend.</div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">üî∂</span>
                            <div class="browser-info">
                                <div class="browser-name">Chrome (older) <span class="warning">flag required</span></div>
                                <div class="browser-steps">
                                    1. Open <code>chrome://flags</code><br>
                                    2. Search "WebGPU"<br>
                                    3. Enable "Unsafe WebGPU"<br>
                                    4. Relaunch browser
                                </div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">ü¶ä</span>
                            <div class="browser-info">
                                <div class="browser-name">Firefox 121+ <span class="check">‚úì</span></div>
                                <div class="browser-steps">WebGPU enabled by default on Windows/macOS.</div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">ü¶ä</span>
                            <div class="browser-info">
                                <div class="browser-name">Firefox (Linux) <span class="warning">flag required</span></div>
                                <div class="browser-steps">
                                    1. Open <code>about:config</code><br>
                                    2. Set <code>dom.webgpu.enabled</code> ‚Üí true<br>
                                    3. Set <code>gfx.webgpu.force-enabled</code> ‚Üí true<br>
                                    4. Restart browser
                                </div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">üêß</span>
                            <div class="browser-info">
                                <div class="browser-name">Chrome/Chromium (Linux) <span class="warning">launch flags</span></div>
                                <div class="browser-steps">
                                    Run in terminal for native Vulkan GPU:<br>
                                    <code id="linuxCmd" style="display:block;margin-top:6px;padding:8px;background:rgba(0,0,0,0.4);border-radius:6px;font-size:11px;word-break:break-all;cursor:pointer;user-select:all;" onclick="navigator.clipboard.writeText(this.textContent);this.style.background='rgba(0,255,0,0.2)';setTimeout(()=>this.style.background='rgba(0,0,0,0.4)',500);" title="Click to copy">chromium --enable-unsafe-webgpu --use-angle=vulkan --enable-features=Vulkan</code>
                                    <span style="font-size:10px;opacity:0.6;">Click command to copy ‚Ä¢ Replace 'chromium' with 'google-chrome' if needed</span>
                                </div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">üß≠</span>
                            <div class="browser-info">
                                <div class="browser-name">Safari 18+ (macOS Sequoia) <span class="check">‚úì</span></div>
                                <div class="browser-steps">WebGPU enabled by default.</div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">üß≠</span>
                            <div class="browser-info">
                                <div class="browser-name">Safari 17 <span class="warning">flag required</span></div>
                                <div class="browser-steps">
                                    1. Safari ‚Üí Settings ‚Üí Advanced<br>
                                    2. Check "Show Develop menu"<br>
                                    3. Develop ‚Üí Feature Flags<br>
                                    4. Enable "WebGPU"
                                </div>
                            </div>
                        </div>
                        <div class="browser-item">
                            <span class="browser-icon">üì±</span>
                            <div class="browser-info">
                                <div class="browser-name">Edge 113+ <span class="check">‚úì</span></div>
                                <div class="browser-steps">WebGPU enabled by default (Chromium-based).</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="error">
        <h2>GPU Acceleration Required</h2>
        <p>Neither WebGPU nor WebGL2 available.<br>
        Try <a href="https://www.google.com/chrome/">Chrome 113+</a> or enable hardware acceleration.</p>
    </div>

    <audio id="preloadAudio" preload="auto" src="mindlang.mp3"></audio>

    <script>
        // ============ WGSL FRAGMENT SHADER (WebGPU) - OPTIMIZED 10/10 Performance ============
        // Techniques: 4x Loop Unrolling, Cardioid Skip, Register Caching, FMA
        const wgslShader = `
            struct Uniforms {
                center: vec2<f32>,
                centerLo: vec2<f32>,
                zoom: f32,
                time: f32,
                maxIter: f32,
                width: f32,
                height: f32,
                fractalType: i32,
                colorScheme: i32,
                audio: f32,
                juliaRe: f32,
                juliaIm: f32,
            }

            @group(0) @binding(0) var<uniform> u: Uniforms;

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) uv: vec2<f32>,
            }

            @vertex
            fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                var pos = array<vec2<f32>, 6>(
                    vec2<f32>(-1.0, -1.0),
                    vec2<f32>(1.0, -1.0),
                    vec2<f32>(-1.0, 1.0),
                    vec2<f32>(-1.0, 1.0),
                    vec2<f32>(1.0, -1.0),
                    vec2<f32>(1.0, 1.0),
                );
                var uv = array<vec2<f32>, 6>(
                    vec2<f32>(0.0, 0.0),
                    vec2<f32>(1.0, 0.0),
                    vec2<f32>(0.0, 1.0),
                    vec2<f32>(0.0, 1.0),
                    vec2<f32>(1.0, 0.0),
                    vec2<f32>(1.0, 1.0),
                );
                var output: VertexOutput;
                output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                output.uv = uv[vertexIndex];
                return output;
            }

            // ===== Cardioid/Bulb Skip: O(1) test saves ~30% of Mandelbrot iterations =====
            fn inCardioidOrBulb(cr: f32, ci: f32) -> bool {
                // Main cardioid check: q(q + (x - 1/4)) < y¬≤/4
                let q = (cr - 0.25) * (cr - 0.25) + ci * ci;
                let inCardioid = q * (q + (cr - 0.25)) < 0.25 * ci * ci;
                // Period-2 bulb: (x + 1)¬≤ + y¬≤ < 1/16
                let inBulb = (cr + 1.0) * (cr + 1.0) + ci * ci < 0.0625;
                return inCardioid || inBulb;
            }

            fn hsv2rgb(h: f32, s: f32, v: f32) -> vec3<f32> {
                let c = v * s;
                let x = c * (1.0 - abs(fract(h * 3.0) * 2.0 - 1.0));
                let m = v - c;
                var rgb: vec3<f32>;
                let hi = i32(floor(h * 6.0)) % 6;
                switch(hi) {
                    case 0: { rgb = vec3<f32>(c, x, 0.0); }
                    case 1: { rgb = vec3<f32>(x, c, 0.0); }
                    case 2: { rgb = vec3<f32>(0.0, c, x); }
                    case 3: { rgb = vec3<f32>(0.0, x, c); }
                    case 4: { rgb = vec3<f32>(x, 0.0, c); }
                    default: { rgb = vec3<f32>(c, 0.0, x); }
                }
                return rgb + m;
            }

            fn getColor(scheme: i32, t: f32, iter: f32, time: f32, audio: f32) -> vec3<f32> {
                switch(scheme) {
                    case 0: { return hsv2rgb(fract(t * 5.0 + time * 0.1 + audio * 2.0), 0.8 + audio * 0.2, 0.9); }
                    case 1: { return vec3<f32>(min(1.0, t * 3.0), max(0.0, (t - 0.33) * 1.8), max(0.0, (t - 0.66) * 0.6)) * (1.0 + audio); }
                    case 2: { return vec3<f32>(t * 0.3, t * 0.6 + audio * 0.3, 0.4 + t * 0.6); }
                    case 3: { let p = t * 12.566 + time * 0.1; return vec3<f32>(0.5 + 0.5 * sin(p), 0.5 + 0.5 * sin(p + 2.094), 0.5 + 0.5 * sin(p + 4.188)) * (1.0 + audio * 0.5); }
                    case 4: { let v = sqrt(t); return vec3<f32>(v, v, v); }
                    case 5: { return hsv2rgb(fract(t * 10.0 + time * 0.1 + audio * 2.0), 0.7 + 0.3 * sin(t * 20.0), 1.0); }
                    case 6: { let x = sin(t * 6.283 + time * 0.1) * 0.5 + 0.5; let y = cos(t * 9.425) * 0.5 + 0.5; return vec3<f32>(x, y * 0.5 + 0.5 * x, 1.0 - x * y) * (1.0 + audio * 0.3); }
                    default: { var c = hsv2rgb(fract(t * 2.0 + 0.7), 0.6 + 0.4 * sin(t * 10.0), 0.3 + t * 0.7); if (fract(sin(iter * 12.9898 + t * 7823.3) * 43758.5453) > 0.98) { c = c + vec3<f32>(1.0 + audio); } return c; }
                }
            }

            // ===== Constants for smooth coloring =====
            const ESCAPE_R: f32 = 256.0;  // Higher escape radius = smoother gradients
            const ESCAPE_R_SQ: f32 = 65536.0;  // 256¬≤

            // ===== 4x Unrolled Mandelbrot with Register Caching + Periodicity Detection =====
            fn mandelbrot4x(cr: f32, ci: f32, maxI: i32) -> vec2<f32> {
                // Cardioid/bulb skip for zoom level 1 (most effective at low zoom)
                if (inCardioidOrBulb(cr, ci)) {
                    return vec2<f32>(f32(maxI), 0.0);
                }

                var zr: f32 = 0.0;
                var zi: f32 = 0.0;
                var zr2: f32 = 0.0;  // Cached zr¬≤
                var zi2: f32 = 0.0;  // Cached zi¬≤
                var iter: f32 = 0.0;

                // Periodicity detection: track orbit for cycle detection
                var ozr: f32 = 0.0;
                var ozi: f32 = 0.0;
                var period: i32 = 0;

                let loopCount = maxI / 4;
                for (var i: i32 = 0; i < 500; i = i + 1) {
                    if (i >= loopCount) { break; }

                    // Iteration 1
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    zi = 2.0 * zr * zi + ci;
                    zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi;
                    iter = iter + 1.0;

                    // Periodicity check every 4 iterations
                    if (abs(zr - ozr) < 1e-10 && abs(zi - ozi) < 1e-10) {
                        return vec2<f32>(f32(maxI), 0.0);  // Cycle detected = in set
                    }
                    period = period + 1;
                    if (period > 20) {
                        ozr = zr; ozi = zi; period = 0;  // Update reference point
                    }

                    // Iteration 2
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    zi = 2.0 * zr * zi + ci;
                    zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi;
                    iter = iter + 1.0;

                    // Iteration 3
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    zi = 2.0 * zr * zi + ci;
                    zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi;
                    iter = iter + 1.0;

                    // Iteration 4
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    zi = 2.0 * zr * zi + ci;
                    zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi;
                    iter = iter + 1.0;
                }

                // Remainder iterations
                let rem = maxI % 4;
                for (var r: i32 = 0; r < 4; r = r + 1) {
                    if (r >= rem) { break; }
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    zi = 2.0 * zr * zi + ci;
                    zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi;
                    iter = iter + 1.0;
                }

                return vec2<f32>(iter, sqrt(zr2 + zi2));
            }

            // ===== 4x Unrolled Julia Set =====
            fn julia4x(z0r: f32, z0i: f32, cr: f32, ci: f32, maxI: i32) -> vec2<f32> {
                var zr: f32 = z0r;
                var zi: f32 = z0i;
                var zr2: f32 = zr * zr;
                var zi2: f32 = zi * zi;
                var iter: f32 = 0.0;

                let loopCount = maxI / 4;
                for (var i: i32 = 0; i < 500; i = i + 1) {
                    if (i >= loopCount) { break; }

                    // 4x unrolled - must save old zr before updating zi
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t1 = zr2 - zi2 + cr; zi = 2.0 * zr * zi + ci; zr = t1;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t2 = zr2 - zi2 + cr; zi = 2.0 * zr * zi + ci; zr = t2;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t3 = zr2 - zi2 + cr; zi = 2.0 * zr * zi + ci; zr = t3;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t4 = zr2 - zi2 + cr; zi = 2.0 * zr * zi + ci; zr = t4;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;
                }

                return vec2<f32>(iter, sqrt(zr2 + zi2));
            }

            // ===== 4x Unrolled Burning Ship =====
            fn burningShip4x(cr: f32, ci: f32, maxI: i32) -> vec2<f32> {
                var zr: f32 = 0.0;
                var zi: f32 = 0.0;
                var iter: f32 = 0.0;

                let loopCount = maxI / 4;
                for (var i: i32 = 0; i < 500; i = i + 1) {
                    if (i >= loopCount) { break; }

                    // 4x unrolled with absolute values
                    var azr = abs(zr); var azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) { break; }
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter = iter + 1.0;

                    azr = abs(zr); azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) { break; }
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter = iter + 1.0;

                    azr = abs(zr); azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) { break; }
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter = iter + 1.0;

                    azr = abs(zr); azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) { break; }
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter = iter + 1.0;
                }

                return vec2<f32>(iter, sqrt(zr * zr + zi * zi));
            }

            // ===== 4x Unrolled Tricorn =====
            fn tricorn4x(cr: f32, ci: f32, maxI: i32) -> vec2<f32> {
                var zr: f32 = 0.0;
                var zi: f32 = 0.0;
                var zr2: f32 = 0.0;
                var zi2: f32 = 0.0;
                var iter: f32 = 0.0;

                let loopCount = maxI / 4;
                for (var i: i32 = 0; i < 500; i = i + 1) {
                    if (i >= loopCount) { break; }

                    // 4x unrolled with conjugate (negative imaginary)
                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t1 = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t1;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t2 = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t2;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t3 = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t3;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) { break; }
                    let t4 = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t4;
                    zr2 = zr * zr; zi2 = zi * zi; iter = iter + 1.0;
                }

                return vec2<f32>(iter, sqrt(zr2 + zi2));
            }

            @fragment
            fn fs_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
                let aspect = u.width / u.height;
                let scale = 3.5 / u.zoom;
                let px = uv.x - 0.5;
                let py = uv.y - 0.5;

                var cr = u.center.x + px * scale * aspect;
                var ci = u.center.y + py * scale;
                let maxI = i32(u.maxIter);

                // Dispatch to optimized fractal function
                var result: vec2<f32>;
                if (u.fractalType == 0) {
                    result = mandelbrot4x(cr, ci, maxI);
                } else if (u.fractalType == 1) {
                    result = julia4x(cr, ci, u.juliaRe, u.juliaIm, maxI);
                } else if (u.fractalType == 2) {
                    result = burningShip4x(cr, ci, maxI);
                } else {
                    result = tricorn4x(cr, ci, maxI);
                }

                let iter = result.x;
                let zmag = result.y;

                // Smooth iteration for anti-banding (using log base of escape radius)
                var smoothI = iter;
                if (iter < u.maxIter && zmag > 1.0) {
                    // smoothI = i + 1 - log‚ÇÇ(log_R(|z|)) where R=256
                    smoothI = iter + 1.0 - log2(log(zmag) / log(ESCAPE_R));
                }

                // Color output
                if (iter >= u.maxIter) {
                    return vec4<f32>(0.0, 0.0, 0.0, 1.0);
                }
                return vec4<f32>(getColor(u.colorScheme, smoothI / u.maxIter, iter, u.time, u.audio), 1.0);
            }
        `;

        // ============ GLSL SHADERS (WebGL2 Fallback) ============
        const glslVS = `#version 300 es
            in vec2 a_pos;
            out vec2 v_uv;
            void main() { v_uv = a_pos * 0.5 + 0.5; gl_Position = vec4(a_pos, 0.0, 1.0); }
        `;

        // ============ GLSL FRAGMENT SHADER (WebGL2) - OPTIMIZED 10/10 Performance ============
        const glslFS = `#version 300 es
            precision highp float;
            in vec2 v_uv;
            out vec4 fragColor;
            uniform vec2 u_center, u_centerLo, u_resolution, u_juliaC;
            uniform float u_zoom, u_time, u_maxIter, u_audio;
            uniform int u_fractalType, u_colorScheme;

            // ===== Constants for smooth coloring =====
            const float ESCAPE_R = 256.0;
            const float ESCAPE_R_SQ = 65536.0;
            const float LOG_ESCAPE_R = 5.545177444479562;  // log(256)

            // ===== Cardioid/Bulb Skip: O(1) test saves ~30% of Mandelbrot iterations =====
            bool inCardioidOrBulb(float cr, float ci) {
                float q = (cr - 0.25) * (cr - 0.25) + ci * ci;
                bool inCardioid = q * (q + (cr - 0.25)) < 0.25 * ci * ci;
                bool inBulb = (cr + 1.0) * (cr + 1.0) + ci * ci < 0.0625;
                return inCardioid || inBulb;
            }

            vec3 hsv2rgb(float h, float s, float v) {
                float c = v * s, x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0)), m = v - c;
                vec3 rgb; int hi = int(floor(h * 6.0)) % 6;
                if (hi == 0) rgb = vec3(c, x, 0.0); else if (hi == 1) rgb = vec3(x, c, 0.0);
                else if (hi == 2) rgb = vec3(0.0, c, x); else if (hi == 3) rgb = vec3(0.0, x, c);
                else if (hi == 4) rgb = vec3(x, 0.0, c); else rgb = vec3(c, 0.0, x);
                return rgb + m;
            }

            vec3 getColor(int scheme, float t, float iter, float time, float audio) {
                if (scheme == 0) return hsv2rgb(fract(t * 5.0 + time * 0.1 + audio * 2.0), 0.8 + audio * 0.2, 0.9);
                if (scheme == 1) return vec3(min(1.0, t * 3.0), max(0.0, (t - 0.33) * 1.8), max(0.0, (t - 0.66) * 0.6)) * (1.0 + audio);
                if (scheme == 2) return vec3(t * 0.3, t * 0.6 + audio * 0.3, 0.4 + t * 0.6);
                if (scheme == 3) { float p = t * 12.566 + time * 0.1; return vec3(0.5 + 0.5 * sin(p), 0.5 + 0.5 * sin(p + 2.094), 0.5 + 0.5 * sin(p + 4.188)) * (1.0 + audio * 0.5); }
                if (scheme == 4) { float v = sqrt(t); return vec3(v); }
                if (scheme == 5) return hsv2rgb(fract(t * 10.0 + time * 0.1 + audio * 2.0), 0.7 + 0.3 * sin(t * 20.0), 1.0);
                if (scheme == 6) { float x = sin(t * 6.283 + time * 0.1) * 0.5 + 0.5, y = cos(t * 9.425) * 0.5 + 0.5; return vec3(x, y * 0.5 + 0.5 * x, 1.0 - x * y) * (1.0 + audio * 0.3); }
                vec3 c = hsv2rgb(fract(t * 2.0 + 0.7), 0.6 + 0.4 * sin(t * 10.0), 0.3 + t * 0.7);
                if (fract(sin(iter * 12.9898 + t * 7823.3) * 43758.5453) > 0.98) c += vec3(1.0 + audio);
                return c;
            }

            // ===== 4x Unrolled Mandelbrot with Register Caching + Periodicity Detection =====
            vec2 mandelbrot4x(float cr, float ci, int maxI) {
                if (inCardioidOrBulb(cr, ci)) return vec2(float(maxI), 0.0);

                float zr = 0.0, zi = 0.0, zr2 = 0.0, zi2 = 0.0, iter = 0.0;
                float ozr = 0.0, ozi = 0.0;  // Periodicity detection
                int period = 0;
                int loopCount = maxI / 4;

                for (int i = 0; i < 500; i++) {
                    if (i >= loopCount) break;

                    // 4x unrolled with FMA
                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    // Periodicity check
                    if (abs(zr - ozr) < 1e-10 && abs(zi - ozi) < 1e-10) return vec2(float(maxI), 0.0);
                    period++; if (period > 20) { ozr = zr; ozi = zi; period = 0; }

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;
                }

                // Remainder
                int rem = maxI - int(iter);
                for (int r = 0; r < 4; r++) {
                    if (r >= rem || zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;
                }

                return vec2(iter, sqrt(zr2 + zi2));
            }

            // ===== 4x Unrolled Julia Set =====
            vec2 julia4x(float z0r, float z0i, float cr, float ci, int maxI) {
                float zr = z0r, zi = z0i, zr2 = zr * zr, zi2 = zi * zi, iter = 0.0;
                int loopCount = maxI / 4;

                for (int i = 0; i < 500; i++) {
                    if (i >= loopCount) break;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    zi = 2.0 * zr * zi + ci; zr = zr2 - zi2 + cr;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;
                }
                return vec2(iter, sqrt(zr2 + zi2));
            }

            // ===== 4x Unrolled Burning Ship =====
            vec2 burningShip4x(float cr, float ci, int maxI) {
                float zr = 0.0, zi = 0.0, iter = 0.0;
                int loopCount = maxI / 4;

                for (int i = 0; i < 500; i++) {
                    if (i >= loopCount) break;

                    float azr = abs(zr), azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) break;
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter += 1.0;

                    azr = abs(zr); azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) break;
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter += 1.0;

                    azr = abs(zr); azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) break;
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter += 1.0;

                    azr = abs(zr); azi = abs(zi);
                    if (azr * azr + azi * azi > ESCAPE_R_SQ) break;
                    zr = azr * azr - azi * azi + cr;
                    zi = 2.0 * azr * azi + ci; iter += 1.0;
                }
                return vec2(iter, sqrt(zr * zr + zi * zi));
            }

            // ===== 4x Unrolled Tricorn =====
            vec2 tricorn4x(float cr, float ci, int maxI) {
                float zr = 0.0, zi = 0.0, zr2 = 0.0, zi2 = 0.0, iter = 0.0;
                int loopCount = maxI / 4;

                for (int i = 0; i < 500; i++) {
                    if (i >= loopCount) break;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    float t = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    t = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    t = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;

                    if (zr2 + zi2 > ESCAPE_R_SQ) break;
                    t = zr2 - zi2 + cr; zi = -2.0 * zr * zi + ci; zr = t;
                    zr2 = zr * zr; zi2 = zi * zi; iter += 1.0;
                }
                return vec2(iter, sqrt(zr2 + zi2));
            }

            void main() {
                float aspect = u_resolution.x / u_resolution.y, scale = 3.5 / u_zoom;
                vec2 uv = v_uv - 0.5;
                float cr = u_center.x + uv.x * scale * aspect;
                float ci = u_center.y + uv.y * scale;
                int maxI = int(u_maxIter);

                vec2 result;
                if (u_fractalType == 0) {
                    result = mandelbrot4x(cr, ci, maxI);
                } else if (u_fractalType == 1) {
                    result = julia4x(cr, ci, u_juliaC.x, u_juliaC.y, maxI);
                } else if (u_fractalType == 2) {
                    result = burningShip4x(cr, ci, maxI);
                } else {
                    result = tricorn4x(cr, ci, maxI);
                }

                float iter = result.x, zmag = result.y;
                float smoothI = iter;
                if (iter < u_maxIter && zmag > 1.0) smoothI = iter + 1.0 - log2(log(zmag) / LOG_ESCAPE_R);
                fragColor = iter >= u_maxIter ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(getColor(u_colorScheme, smoothI / u_maxIter, iter, u_time, u_audio), 1.0);
            }
        `;

        // ============ GLOBALS ============
        const canvas = document.getElementById('canvas');
        const info = document.getElementById('info');
        const gpuInfoDiv = document.getElementById('gpuInfo');
        const errorDiv = document.getElementById('error');
        const apiBadge = document.getElementById('apiBadge');

        let renderer = null; // 'webgpu' or 'webgl2'
        let selectedApi = null; // User's preferred API
        let webgpuAvailable = false; // Whether WebGPU is available
        let gpuDevice, gpuContext, gpuRenderPipeline, gpuUniformBuffer, gpuBindGroup, canvasFormat;
        let gl, glProgram, glUniforms = {};
        let gpuName = 'Unknown GPU';
        let gpuReady = false;

        const FRACTALS = ['Mandelbrot', 'Julia', 'Burning Ship', 'Tricorn'];
        const COLORS = ['Electric', 'Fire', 'Ocean', 'Neon', 'Grayscale', 'Psychedelic', 'Plasma', 'Galaxy'];

        let autoZoom = false;
        const ZOOM_TARGETS = [
            { center: [-0.7436438870371587, 0.1318259043124868], name: 'Seahorse Valley' },
            { center: [-0.7453916408500898, 0.1130870119194893], name: 'Elephant Valley' },
            { center: [-1.2500659476977586, 0.0200129382827858], name: 'Spiral Arms' },
            { center: [-0.1010963638456222, 0.9562865108091415], name: 'Lightning' },
            { center: [0.0016437219711533, -0.8224676332988767], name: 'Mini Mandelbrot' },
            { center: [-0.7498540975613495, 0.0122324395898474], name: 'Valley of Stars' },
            { center: [-0.1528556765138503, 1.0397665953210492], name: 'Spiral Galaxy' },
            { center: [-0.7256022041509915, 0.2478383655498645], name: 'Double Spiral' },
        ];
        let currentTarget = 0;

        let state = {
            center: [-0.5, 0], targetCenter: [-0.5, 0],
            zoom: 1, targetZoom: 1, time: 0,
            fractalType: 0, colorScheme: 0, audioIntensity: 0,
            juliaC: [-0.7, 0.27015], maxIter: 100,
            audioEnabled: false, audioSource: null,
            resolution: 'auto',
        };

        // Performance tracking
        let frameCount = 0, lastFpsTime = performance.now(), fps = 0;
        let totalPixels = 0, pixelsPerSecond = 0;

        function splitDouble(x) { return [x, x - x]; }

        // ============ WebGPU INIT ============
        async function initWebGPU() {
            if (!navigator.gpu) return false;
            try {
                const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
                if (!adapter) return false;

                const adapterInfo = await adapter.requestAdapterInfo?.() || {};
                gpuName = adapterInfo.description || adapterInfo.device || 'WebGPU Device';

                gpuDevice = await adapter.requestDevice();
                gpuContext = canvas.getContext('webgpu');
                canvasFormat = navigator.gpu.getPreferredCanvasFormat();
                gpuContext.configure({ device: gpuDevice, format: canvasFormat, alphaMode: 'opaque' });

                // Single render pipeline (fragment shader) - much faster than compute shader
                const shaderModule = gpuDevice.createShaderModule({ code: wgslShader });
                gpuUniformBuffer = gpuDevice.createBuffer({ size: 64, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                const bindGroupLayout = gpuDevice.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    ]
                });

                gpuRenderPipeline = gpuDevice.createRenderPipeline({
                    layout: gpuDevice.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                    vertex: { module: shaderModule, entryPoint: 'vs_main' },
                    fragment: {
                        module: shaderModule,
                        entryPoint: 'fs_main',
                        targets: [{ format: canvasFormat }],
                    },
                    primitive: { topology: 'triangle-list' },
                });

                gpuBindGroup = gpuDevice.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: gpuUniformBuffer } },
                    ]
                });

                renderer = 'webgpu';
                return true;
            } catch (e) { console.error('WebGPU init failed:', e); return false; }
        }

        // ============ WebGL2 INIT ============
        function initWebGL2() {
            try {
                console.log('initWebGL2: attempting canvas.getContext("webgl2")');
                gl = canvas.getContext('webgl2');
                console.log('initWebGL2: gl =', gl);
                if (!gl) {
                    console.error('initWebGL2: Failed to get WebGL2 context');
                    return false;
                }

                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                gpuName = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'WebGL2 Device';
                console.log('initWebGL2: GPU =', gpuName);

                function createShader(type, source) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                        return null;
                    }
                    return shader;
                }

                console.log('initWebGL2: Creating shaders...');
                const vs = createShader(gl.VERTEX_SHADER, glslVS);
                const fs = createShader(gl.FRAGMENT_SHADER, glslFS);
                console.log('initWebGL2: vs =', !!vs, 'fs =', !!fs);
                if (!vs || !fs) {
                    console.error('initWebGL2: Shader creation failed');
                    return false;
                }

            glProgram = gl.createProgram();
            gl.attachShader(glProgram, vs);
            gl.attachShader(glProgram, fs);
            gl.linkProgram(glProgram);
            gl.useProgram(glProgram);

            const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

            const aPos = gl.getAttribLocation(glProgram, 'a_pos');
            gl.enableVertexAttribArray(aPos);
            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

            ['center', 'centerLo', 'zoom', 'time', 'maxIter', 'resolution', 'fractalType', 'colorScheme', 'audio', 'juliaC'].forEach(n => {
                glUniforms[n] = gl.getUniformLocation(glProgram, 'u_' + n);
            });

                console.log('initWebGL2: Success!');
                renderer = 'webgl2';
                return true;
            } catch (e) {
                console.error('initWebGL2 exception:', e);
                return false;
            }
        }

        // ============ RESIZE ============
        function resize() {
            const res = state.resolution;
            let w, h;
            if (res === 'auto') {
                // Use 1:1 pixel ratio, cap to 1080p for smooth performance
                w = window.innerWidth;
                h = window.innerHeight;
                // Cap to ~2MP (1080p) for smooth 60fps
                const maxPixels = 2073600;
                if (w * h > maxPixels) {
                    const scale = Math.sqrt(maxPixels / (w * h));
                    w = Math.floor(w * scale);
                    h = Math.floor(h * scale);
                }
            } else {
                [w, h] = res.split('x').map(Number);
            }
            canvas.width = w; canvas.height = h;
            if (renderer === 'webgl2' && gl) gl.viewport(0, 0, w, h);
        }

        function lerp(a, b, t) { return a + (b - a) * t; }
        function toggleAutoZoom() { autoZoom = !autoZoom; if (autoZoom) pickNewTarget(); }
        function pickNewTarget() { state.targetCenter = [...ZOOM_TARGETS[currentTarget].center]; currentTarget = (currentTarget + 1) % ZOOM_TARGETS.length; }
        function resetView() { state.targetCenter = [-0.5, 0]; state.center = [-0.5, 0]; state.targetZoom = 1; state.zoom = 1; }

        // ============ RENDER ============
        let lastTime = performance.now();
        function render() {
            if (!gpuReady) { requestAnimationFrame(render); return; }

            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            // FPS calculation
            frameCount++;
            if (now - lastFpsTime >= 1000) {
                fps = frameCount;
                totalPixels = canvas.width * canvas.height;
                pixelsPerSecond = totalPixels * fps;
                frameCount = 0;
                lastFpsTime = now;
            }

            const smooth = 1 - Math.pow(0.1, dt * 60);
            state.center[0] = lerp(state.center[0], state.targetCenter[0], smooth);
            state.center[1] = lerp(state.center[1], state.targetCenter[1], smooth);
            state.zoom = lerp(state.zoom, state.targetZoom, smooth);
            state.time += dt;
            state.maxIter = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 30));

            if (autoZoom) {
                state.targetZoom *= 1.0 + dt * 0.5; // Faster zoom
                // Max zoom per fractal: Mandelbrot 50k, Julia 300k, Burning Ship 50k, Tricorn 100k
                const maxZooms = [50000, 300000, 50000, 100000];
                const maxZoom = maxZooms[state.fractalType];
                if (state.zoom > maxZoom) {
                    // Switch to next fractal type (loop through all 4)
                    state.fractalType = (state.fractalType + 1) % 4;
                    pickNewTarget();
                    state.center = [...state.targetCenter];
                    state.zoom = 1;
                    state.targetZoom = 1;
                }
            }

            if (state.audioEnabled && analyser) {
                analyser.getByteFrequencyData(audioData);
                let sum = 0; for (let i = 0; i < audioData.length; i++) sum += audioData[i];
                state.audioIntensity = (sum / audioData.length / 255) * 0.5;
            } else { state.audioIntensity *= 0.95; }

            const [cxHi, cxLo] = splitDouble(state.center[0]);
            const [cyHi, cyLo] = splitDouble(state.center[1]);

            if (renderer === 'webgpu') {
                const uniforms = new Float32Array([cxHi, cyHi, cxLo, cyLo, state.zoom, state.time, state.maxIter, canvas.width, canvas.height, 0, 0, 0, 0, 0]);
                const uniformsInt = new Int32Array(uniforms.buffer);
                uniformsInt[9] = state.fractalType; uniformsInt[10] = state.colorScheme;
                const uniformsFloat2 = new Float32Array(uniforms.buffer);
                uniformsFloat2[11] = state.audioIntensity; uniformsFloat2[12] = state.juliaC[0]; uniformsFloat2[13] = state.juliaC[1];
                gpuDevice.queue.writeBuffer(gpuUniformBuffer, 0, uniforms);

                const encoder = gpuDevice.createCommandEncoder();

                // Single render pass - directly render fractal to canvas (no compute pass)
                const renderPass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: gpuContext.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        clearValue: { r: 0, g: 0, b: 0, a: 1 },
                        storeOp: 'store',
                    }]
                });
                renderPass.setPipeline(gpuRenderPipeline);
                renderPass.setBindGroup(0, gpuBindGroup);
                renderPass.draw(6);
                renderPass.end();

                gpuDevice.queue.submit([encoder.finish()]);
            } else {
                gl.uniform2f(glUniforms.center, cxHi, cyHi);
                gl.uniform2f(glUniforms.centerLo, cxLo, cyLo);
                gl.uniform1f(glUniforms.zoom, state.zoom);
                gl.uniform1f(glUniforms.time, state.time);
                gl.uniform1f(glUniforms.maxIter, state.maxIter);
                gl.uniform2f(glUniforms.resolution, canvas.width, canvas.height);
                gl.uniform1i(glUniforms.fractalType, state.fractalType);
                gl.uniform1i(glUniforms.colorScheme, state.colorScheme);
                gl.uniform1f(glUniforms.audio, state.audioIntensity);
                gl.uniform2f(glUniforms.juliaC, state.juliaC[0], state.juliaC[1]);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            // Update info display
            const audioStatus = state.audioSource === 'mic' ? ' üé§' : state.audioSource === 'file' ? ' üéµ' : '';
            const apiClass = renderer === 'webgpu' ? 'webgpu' : 'webgl2';
            const apiName = renderer === 'webgpu' ? 'WebGPU' : 'WebGL2';
            const zoomStr = state.zoom >= 1e9 ? state.zoom.toExponential(2) : state.zoom.toFixed(1);
            const mpps = (pixelsPerSecond / 1e6).toFixed(1);
            const mp = (totalPixels / 1e6).toFixed(2);
            const resLabel = state.resolution === 'auto' ? 'Auto DPI' : state.resolution;

            info.innerHTML = `
                <div class="title">Fractal Voyager <span class="api ${apiClass}">${apiName}</span> <span class="api ${apiClass}">${resLabel}</span></div>
                <div class="stats">
                    <span class="highlight">${FRACTALS[state.fractalType]}</span> <span class="dim">|</span>
                    ${COLORS[state.colorScheme]} <span class="dim">|</span>
                    <span class="perf">${fps} FPS</span>${audioStatus}<br>
                    <span class="dim">Zoom:</span> <span class="highlight">${zoomStr}√ó</span>
                    <span class="dim">| Iter:</span> ${state.maxIter}
                    <span class="dim">| Auto:</span> ${autoZoom ? '<span class="perf">ON</span>' : 'OFF'}
                </div>
            `;

            gpuInfoDiv.innerHTML = `
                <div><span class="label">GPU:</span> ${gpuName.substring(0, 40)}</div>
                <div><span class="label">Resolution:</span> ${canvas.width}√ó${canvas.height} (${mp}MP)</div>
                <div><span class="label">Throughput:</span> ${mpps} MP/s</div>
                <div><span class="label">Precision:</span> 32-bit (fast)</div>
                <div><span class="label">Workgroups:</span> ${Math.ceil(canvas.width/16)}√ó${Math.ceil(canvas.height/16)} (16√ó16)</div>
            `;

            // Show GitHub link near end of audio track (last 15 seconds)
            const githubLink = document.getElementById('githubLink');
            if (audioElement && audioElement.duration && !audioElement.paused) {
                const timeLeft = audioElement.duration - audioElement.currentTime;
                if (timeLeft <= 15 && timeLeft > 0) {
                    githubLink.classList.add('visible');
                } else {
                    githubLink.classList.remove('visible');
                }
            } else {
                githubLink.classList.remove('visible');
            }

            requestAnimationFrame(render);
        }

        // ============ INPUT HANDLING ============
        let isDragging = false, lastMouse = [0, 0];
        let audioContext, analyser, audioData, audioElement, audioFileSource;

        window.addEventListener('resize', resize);
        canvas.addEventListener('wheel', e => { e.preventDefault(); state.targetZoom *= e.deltaY > 0 ? 0.9 : 1.1; }, { passive: false });
        canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = [e.clientX, e.clientY]; });
        canvas.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = e.clientX - lastMouse[0], dy = e.clientY - lastMouse[1];
            lastMouse = [e.clientX, e.clientY];
            const scale = 3.5 / state.zoom, aspect = canvas.width / canvas.height;
            state.targetCenter[0] -= dx / canvas.width * scale * aspect;
            state.targetCenter[1] += dy / canvas.height * scale;
        });
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        let lastTouch = null, lastDist = null;
        canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) lastTouch = [e.touches[0].clientX, e.touches[0].clientY];
            else if (e.touches.length === 2) { const dx = e.touches[1].clientX - e.touches[0].clientX, dy = e.touches[1].clientY - e.touches[0].clientY; lastDist = Math.sqrt(dx*dx + dy*dy); }
        }, { passive: true });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 1 && lastTouch) {
                const dx = e.touches[0].clientX - lastTouch[0], dy = e.touches[0].clientY - lastTouch[1];
                lastTouch = [e.touches[0].clientX, e.touches[0].clientY];
                const scale = 3.5 / state.zoom, aspect = canvas.width / canvas.height;
                state.targetCenter[0] -= dx / canvas.width * scale * aspect;
                state.targetCenter[1] += dy / canvas.height * scale;
            } else if (e.touches.length === 2 && lastDist) {
                const dx = e.touches[1].clientX - e.touches[0].clientX, dy = e.touches[1].clientY - e.touches[0].clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                state.targetZoom *= dist / lastDist; lastDist = dist;
            }
        }, { passive: false });
        canvas.addEventListener('touchend', () => { lastTouch = null; lastDist = null; });

        document.addEventListener('keydown', e => {
            switch (e.key) {
                case '1': state.fractalType = 0; resetView(); break;
                case '2': state.fractalType = 1; resetView(); break;
                case '3': state.fractalType = 2; resetView(); break;
                case '4': state.fractalType = 3; resetView(); break;
                case 'c': case 'C': state.colorScheme = (state.colorScheme + 1) % 8; break;
                case 'a': case 'A': toggleMicAudio(); break;
                case 'm': case 'M': document.getElementById('audioFile').click(); break;
                case 'z': case 'Z': toggleAutoZoom(); break;
                case 'r': case 'R': autoZoom = false; resetView(); break;
            }
        });

        async function toggleMicAudio() {
            if (state.audioSource === 'mic') { state.audioEnabled = false; state.audioSource = null; return; }
            try {
                if (!audioContext) audioContext = new AudioContext();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
                audioContext.createMediaStreamSource(stream).connect(analyser);
                audioData = new Uint8Array(analyser.frequencyBinCount);
                state.audioEnabled = true; state.audioSource = 'mic';
            } catch (e) { console.error('Mic access denied:', e); }
        }

        document.getElementById('audioFile').addEventListener('change', async e => {
            const file = e.target.files[0]; if (!file) return;
            try {
                if (!audioContext) audioContext = new AudioContext();
                if (audioElement) { audioElement.pause(); audioElement.remove(); }
                audioElement = new Audio(); audioElement.src = URL.createObjectURL(file); audioElement.loop = true;
                audioFileSource = audioContext.createMediaElementSource(audioElement);
                analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
                audioFileSource.connect(analyser); analyser.connect(audioContext.destination);
                audioData = new Uint8Array(analyser.frequencyBinCount);
                await audioElement.play();
                state.audioEnabled = true; state.audioSource = 'file';
            } catch (e) { console.error('Audio file error:', e); }
        });

        document.getElementById('resolution').addEventListener('change', e => { state.resolution = e.target.value; resize(); });

        // Mute button handler
        document.getElementById('muteBtn').addEventListener('click', () => {
            if (audioElement) {
                if (audioElement.paused) {
                    audioElement.play();
                    document.getElementById('muteBtn').textContent = 'üîä';
                    document.getElementById('muteBtn').classList.add('active');
                } else {
                    audioElement.pause();
                    state.audioIntensity = 0; // Stop audio reactivity immediately
                    document.getElementById('muteBtn').textContent = 'üîá';
                    document.getElementById('muteBtn').classList.remove('active');
                }
            }
        });

        // Auto-zoom button handler
        document.getElementById('autoBtn').addEventListener('click', () => {
            toggleAutoZoom();
            const btn = document.getElementById('autoBtn');
            if (autoZoom) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // Fractal button handler (mobile)
        document.getElementById('fractalBtn').addEventListener('click', () => {
            state.fractalType = (state.fractalType + 1) % 4;
            resetView();
        });

        // Color button handler (mobile)
        document.getElementById('colorBtn').addEventListener('click', () => {
            state.colorScheme = (state.colorScheme + 1) % 8;
        });

        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', e => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file?.type.startsWith('audio/')) {
                document.getElementById('audioFile').files = e.dataTransfer.files;
                document.getElementById('audioFile').dispatchEvent(new Event('change'));
            }
        });

        // ============ DEMO STARTUP ============
        async function loadDemoMusic() {
            try {
                audioElement = document.getElementById('preloadAudio');
                audioElement.loop = true; audioElement.volume = 1.0; audioElement.currentTime = 0;
                await audioElement.play();
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.resume();
                audioFileSource = audioContext.createMediaElementSource(audioElement);
                analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
                audioFileSource.connect(analyser); analyser.connect(audioContext.destination);
                audioData = new Uint8Array(analyser.frequencyBinCount);
                state.audioEnabled = true; state.audioSource = 'file';
            } catch (e) { console.error('Demo music error:', e); }
        }

        let demoStarted = false;
        function startDemo() {
            if (demoStarted) return;
            demoStarted = true;
            const btnText = document.querySelector('#startBtn .btn-text');
            if (btnText) btnText.textContent = 'Loading...';
            // Defer heavy work to avoid blocking click handler
            requestAnimationFrame(async () => {
                try {
                    // Wait for API detection if not complete
                    if (typeof apiDetectionComplete !== 'undefined' && !apiDetectionComplete) {
                        await new Promise(resolve => {
                            const check = setInterval(() => {
                                if (apiDetectionComplete) { clearInterval(check); resolve(); }
                            }, 50);
                        });
                    }
                    console.log('Starting demo. selectedApi:', selectedApi, 'webgpuAvailable:', webgpuAvailable);
                    // Initialize the renderer first
                    await init();
                    await loadDemoMusic();
                    if (state.audioSource === 'file') {
                        document.getElementById('startHint').style.display = 'none';
                        toggleAutoZoom();
                    } else { if (btnText) btnText.textContent = 'Click here to start'; demoStarted = false; }
                } catch (e) {
                    console.error('startDemo error:', e);
                    if (btnText) btnText.textContent = 'Click here to start';
                    demoStarted = false;
                }
            });
        }

        // Only start on button click or spacebar
        document.getElementById('startBtn').addEventListener('click', startDemo);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !demoStarted) {
                e.preventDefault();
                startDemo();
            }
        });

        // Browser help toggle
        document.getElementById('browserHelpToggle').addEventListener('click', (e) => {
            e.stopPropagation();
            const toggle = document.getElementById('browserHelpToggle');
            const instructions = document.getElementById('browserInstructions');
            toggle.classList.toggle('expanded');
            instructions.classList.toggle('visible');
        });

        // ============ API DETECTION ============
        async function detectApis() {
            // Check WebGPU availability
            if (navigator.gpu) {
                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    webgpuAvailable = !!adapter;
                } catch (e) {
                    webgpuAvailable = false;
                }
            }

            // Update start screen buttons
            const startWebgpuBtn = document.getElementById('startWebgpuBtn');
            const startWebgl2Btn = document.getElementById('startWebgl2Btn');
            const webgpuBtn = document.getElementById('webgpuBtn');
            const webgl2Btn = document.getElementById('webgl2Btn');

            // Detect browser - Firefox WebGPU is 20x slower than WebGL2
            const isFirefox = navigator.userAgent.includes('Firefox');
            const isChrome = navigator.userAgent.includes('Chrome') && !navigator.userAgent.includes('Edge');

            // Check URL for force mode
            const urlParams = new URLSearchParams(window.location.search);
            const forceRenderer = urlParams.get('renderer');

            // Set default selection based on availability and browser
            if (forceRenderer === 'webgpu' && webgpuAvailable) {
                selectedApi = 'webgpu';
            } else if (forceRenderer === 'webgl2') {
                selectedApi = 'webgl2';
            } else if (webgpuAvailable && isChrome) {
                selectedApi = 'webgpu';
            } else {
                selectedApi = 'webgl2';
            }

            // Update UI for WebGPU availability
            if (!webgpuAvailable) {
                startWebgpuBtn.classList.add('unavailable');
                startWebgpuBtn.title = 'WebGPU not available in this browser';
                webgpuBtn.classList.add('unavailable');
                webgpuBtn.title = 'WebGPU not available';
            }

            // Set initial active state
            updateApiSelection(selectedApi);

            // Update badge
            if (webgpuAvailable) {
                apiBadge.textContent = selectedApi === 'webgpu' ? 'WebGPU Ready' : 'WebGL2 Selected';
            } else {
                apiBadge.textContent = 'WebGL2 Only';
            }
            apiBadge.className = 'api-badge ' + selectedApi;
        }

        function updateApiSelection(api) {
            selectedApi = api;
            const startWebgpuBtn = document.getElementById('startWebgpuBtn');
            const startWebgl2Btn = document.getElementById('startWebgl2Btn');
            const webgpuBtn = document.getElementById('webgpuBtn');
            const webgl2Btn = document.getElementById('webgl2Btn');

            // Start screen buttons
            startWebgpuBtn.classList.remove('active', 'webgpu');
            startWebgl2Btn.classList.remove('active', 'webgl2');
            if (api === 'webgpu' && webgpuAvailable) {
                startWebgpuBtn.classList.add('active', 'webgpu');
            } else {
                startWebgl2Btn.classList.add('active', 'webgl2');
                selectedApi = 'webgl2';
            }

            // Top bar buttons
            webgpuBtn.classList.remove('active', 'webgpu');
            webgl2Btn.classList.remove('active', 'webgl2');
            if (selectedApi === 'webgpu') {
                webgpuBtn.classList.add('active', 'webgpu');
            } else {
                webgl2Btn.classList.add('active', 'webgl2');
            }

            // Update badge
            apiBadge.textContent = selectedApi === 'webgpu' ? 'WebGPU Ready' : 'WebGL2 Selected';
            apiBadge.className = 'api-badge ' + selectedApi;
        }

        // ============ INIT ============
        async function init() {
            let hasWebGPU = false;
            let hasWebGL2 = false;

            console.log('init() called. selectedApi:', selectedApi);

            // Initialize based on selected API (default to webgl2 if not set)
            if (selectedApi === 'webgpu') {
                console.log('Trying WebGPU first...');
                hasWebGPU = await initWebGPU();
                console.log('WebGPU result:', hasWebGPU);
                if (!hasWebGPU) {
                    // Fallback to WebGL2
                    console.log('WebGPU failed, falling back to WebGL2...');
                    hasWebGL2 = initWebGL2();
                    console.log('WebGL2 result:', hasWebGL2);
                }
            } else {
                // Try WebGL2 first (default)
                console.log('Trying WebGL2 first...');
                hasWebGL2 = initWebGL2();
                console.log('WebGL2 result:', hasWebGL2);
                if (!hasWebGL2) {
                    // Fallback to WebGPU
                    console.log('WebGL2 failed, falling back to WebGPU...');
                    hasWebGPU = await initWebGPU();
                    console.log('WebGPU result:', hasWebGPU);
                }
            }

            if (!hasWebGPU && !hasWebGL2) {
                console.error('Both WebGPU and WebGL2 failed to initialize!');
                console.error('navigator.gpu:', !!navigator.gpu);
                console.error('canvas.getContext("webgl2"):', !!canvas.getContext('webgl2'));
                errorDiv.style.display = 'block';
                document.getElementById('startHint').style.display = 'none';
                return;
            }

            apiBadge.textContent = renderer === 'webgpu' ? 'WebGPU Compute' : 'WebGL2 Fragment';
            apiBadge.className = 'api-badge ' + renderer;

            // Update API switcher state
            const webgpuBtn = document.getElementById('webgpuBtn');
            const webgl2Btn = document.getElementById('webgl2Btn');
            webgpuBtn.classList.remove('active', 'webgpu');
            webgl2Btn.classList.remove('active', 'webgl2');
            if (renderer === 'webgpu') {
                webgpuBtn.classList.add('active', 'webgpu');
            } else {
                webgl2Btn.classList.add('active', 'webgl2');
            }

            resize();
            gpuReady = true;
            // Defer first render to next frame to avoid blocking
            requestAnimationFrame(render);
        }

        // Start screen API selector handlers
        document.getElementById('startWebgpuBtn').addEventListener('click', () => {
            if (webgpuAvailable) {
                updateApiSelection('webgpu');
            }
        });
        document.getElementById('startWebgl2Btn').addEventListener('click', () => {
            updateApiSelection('webgl2');
        });

        // Top bar API switcher handlers (reload with URL param)
        document.getElementById('webgpuBtn').addEventListener('click', () => {
            if (!webgpuAvailable) return;
            const url = new URL(window.location);
            url.searchParams.set('renderer', 'webgpu');
            window.location.href = url.toString();
        });
        document.getElementById('webgl2Btn').addEventListener('click', () => {
            const url = new URL(window.location);
            url.searchParams.set('renderer', 'webgl2');
            window.location.href = url.toString();
        });

        // Detect APIs first, then wait for user to start
        let apiDetectionComplete = false;
        (async () => {
            await detectApis();
            apiDetectionComplete = true;
            console.log('API Detection complete. WebGPU:', webgpuAvailable, 'Selected:', selectedApi);
        })();
    </script>
</body>
</html>
