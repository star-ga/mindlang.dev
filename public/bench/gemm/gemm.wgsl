// GEMM Benchmark - Compiled WGSL Shader
// Generated by MIND Compiler v0.1.0
// Copyright (c) 2026 STARGA Inc. - MIT License
//
// Tiled 4096×4096 matrix multiplication.
// 16×16 workgroups with shared memory tiling.

struct GemmParams {
    M: u32,
    N: u32,
    K: u32,
    alpha: f32,
}

@group(0) @binding(0) var<uniform> params: GemmParams;
@group(0) @binding(1) var<storage, read> A: array<f32>;
@group(0) @binding(2) var<storage, read> B: array<f32>;
@group(0) @binding(3) var<storage, read_write> C: array<f32>;

var<workgroup> tile_a: array<f32, 256>;  // 16×16
var<workgroup> tile_b: array<f32, 256>;  // 16×16

@compute @workgroup_size(16, 16, 1)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id) lid: vec3<u32>) {
    let row = gid.y;
    let col = gid.x;
    let lr = lid.y;
    let lc = lid.x;

    let M = params.M;
    let N = params.N;
    let K = params.K;

    var acc: f32 = 0.0;
    let num_tiles = (K + 15u) / 16u;

    for (var t: u32 = 0u; t < num_tiles; t = t + 1u) {
        let tile_offset = t * 16u;

        // Load tile of A into shared memory
        let a_col = tile_offset + lc;
        if (row < M && a_col < K) {
            tile_a[lr * 16u + lc] = A[row * K + a_col];
        } else {
            tile_a[lr * 16u + lc] = 0.0;
        }

        // Load tile of B into shared memory
        let b_row = tile_offset + lr;
        if (b_row < K && col < N) {
            tile_b[lr * 16u + lc] = B[b_row * N + col];
        } else {
            tile_b[lr * 16u + lc] = 0.0;
        }

        workgroupBarrier();

        // Accumulate dot product
        for (var k: u32 = 0u; k < 16u; k = k + 1u) {
            acc = acc + tile_a[lr * 16u + k] * tile_b[k * 16u + lc];
        }

        workgroupBarrier();
    }

    // Write result
    if (row < M && col < N) {
        C[row * N + col] = params.alpha * acc;
    }
}
